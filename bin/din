#!/usr/bin/env python

import sys
import gtk
import re

APP_NAME = "din"
APP_VERSION = (0, 1, 0)

TITLE = "%s v%d.%d.%d" % ((APP_NAME,) + APP_VERSION)

class DinEndOfCommandException(Exception):
    pass

class DinUnexpectedEndOfCommandException(Exception):
    pass

class DinCommandParser(object):
    def __init__(self):
        object.__init__(self)

        self.command = None
        self.offset = None

    def parse(self, command):
        self.command = command
        self.offset = 0
        return [arg for arg in self]

    def __iter__(self):
        try:
            while True:
                yield self.getnext()
        except DinEndOfCommandException:
            pass

    def getnext(self):
        c = self.c
        n = self.n

        self.checkeoc()

        while c().isspace():
            n()

        if c() in ('"', "'"):
            return self.quoted()
        else:
            return self.simple()

    def parsewhile(self, pred, eoc, escape, skiplast):
        c = self.c
        n = self.n

        escaped = False
        temp = ""
        try:
            while pred(c(), escaped):
                if escaped:
                    if escape: temp += escape(c())
                    escaped = False
                else:
                    if c() == "\\":
                        escaped = True
                    else:
                        temp += c()
                n()
            if skiplast and not self.iseoc(): n()
        except DinEndOfCommandException:
            if eoc:
                eoc(temp, escaped)
            else:
                raise

        return temp

    def makesimplepred(self):
        def simple_predicate(c, escaped):
            return (not c.isspace()) or escaped
        return simple_predicate

    def simpleeoc(self, temp, escaped):
        # try to handle a "bad" escape gracefully
        if escaped: temp += "\\"

    def makesimpleescape(self):
        def simple_escape(c):
            if c.isspace() or c == "\\":
                return c
            return "\\" + c
        return simple_escape

    def simple(self):
        pred = self.makesimplepred()
        eoc = self.simpleeoc
        escape = self.makesimpleescape()
        return self.parsewhile(pred, eoc, escape, False)

    def makequotedpred(self, q):
        def quoted_predicate(c, escaped):
            return c != q or escaped
        return quoted_predicate

    def quotedeoc(self, temp, escaped):
        raise DinUnexpectedEndOfCommand("unterminated quote")

    def makequotedescape(self, q):
        def quoted_escape(c):
            if c == q:
                return c
            return "\\" + c
        return quoted_escape

    def quoted(self):
        q = self.c()
        self.n()

        pred = self.makequotedpred(q)
        eoc = self.quotedeoc
        escape = self.makequotedescape(q)
        return self.parsewhile(pred, eoc, escape, True)

    def c(self):
        return self.command[self.offset]

    def n(self):
        self.checkeoc()
        self.offset += 1

    def iseoc(self):
        return self.offset+1 >= len(self.command)

    def checkeoc(self):
        if self.iseoc():
            raise DinEndOfCommandException()

class DinEngine(object):
    def __init__(self):
        object.__init__(self)

        self.commandparser = DinCommandParser()

    def execute(self, command):
        print self.commandparser.parse(command)

class DinPopupMenu(gtk.Menu):
    def __init__(self):
        gtk.Menu.__init__(self)

        self.quit_menuitem = gtk.MenuItem("_Quit")
        self.quit_menuitem.show_all()
        self.append(self.quit_menuitem)

    def onquit(self, handler):
        self.quit_menuitem.connect("activate", handler)

class DinWindow(gtk.Window):
    def __init__(self, engine):
        gtk.Window.__init__(self)
        
        self.engine = engine

        self.entry = gtk.Entry()
        self.entry.connect("key-release-event", self.entry_keyrelease)
        self.entry.connect("activate", self.entry_activate)
        self.button = gtk.Button("Go")
        self.button.connect("clicked", self.button_clicked)

        hbox = gtk.HBox(False, 0)
        hbox.pack_start(self.entry, True, True, 0)
        hbox.pack_start(self.button, False, False, 0)

        self.add(hbox)

    def show(self):
        self.entry.select_region(0, -1)
        gtk.Window.show(self)

    def entry_activate(self, widget):
        self.button.activate()

    def entry_keyrelease(self, widget, event):
        if event.keyval == gtk.gdk.keyval_from_name("Escape"):
            self.hide()

    def button_clicked(self, widget):
        self.engine.execute(self.entry.get_text())
        self.hide()

def toggle_visible_handler(widget):
    def impl(sender, *args):
        if widget.get_visible():
            widget.hide()
        else:
            widget.show()
    return impl

def window_deleteevent(window):
    return toggle_visible_handler(window)

def statusicon_activate(window):
    return toggle_visible_handler(window)

def statusicon_popupmenu(menu):
    def impl(sender, button, timestamp):
        menu.popup(None, None, None, button, timestamp)
    return impl

def main():
    engine = DinEngine()

    window = DinWindow(engine)
    window.set_title(TITLE)
    window.set_position(gtk.WIN_POS_CENTER)
    window.connect("delete-event", window_deleteevent(window))

    popupmenu = DinPopupMenu()
    popupmenu.onquit(gtk.main_quit)

    statusicon = gtk.status_icon_new_from_stock(gtk.STOCK_OPEN)
    statusicon.set_tooltip(TITLE)
    statusicon.connect("activate", statusicon_activate(window))
    statusicon.connect("popup-menu", statusicon_popupmenu(popupmenu))

    window.show_all()
    statusicon.set_visible(True)

    gtk.main()

if __name__ == "__main__":
    main()

